directive @accessibleIf(cond: String) on FIELD_DEFINITION

directive @constraints(min: Int, max: Int, pattern: String) on INPUT_FIELD_DEFINITION

directive @ignore on OBJECT | INTERFACE

directive @internal(method: String!) on OBJECT | INTERFACE

type AccessToken {
  id: ID!
  token: String!
  view: View!
  type: AccessTokenType!
  emails: [String!]!
  createdBy: User!
  createdAt: DateTime!
  lastAccessedAt: DateTime
  revokedAt: DateTime
  projects: [Project!]!
}

enum AccessTokenType {
  PUBLIC
  RESTRICTED
  INDIVIDUAL_SHARING
}

input AckRunQueueItemInput {
  runQueueItemId: ID!
  runName: String!
  clientMutationId: String
}

type AckRunQueueItemPayload {
  success: Boolean
  clientMutationId: String
}

type ActiveExperiment implements Node {
  id: ID!
  name: String!
  activeVariants: [ActiveVariant!]!
  experimentType: ExperimentType!
  startAt: DateTime
  endAt: DateTime
}

type ActiveVariant {
  bucket: Int!
  allocation: Int!
}

input AddAliasesInput {
  aliases: [ArtifactCollectionAliasInput!]!
  artifactID: ID!
  clientMutationId: String
}

type AddAliasesPayload {
  success: Boolean!
  clientMutationId: String
}

input AddFilesInput {
  names: [String]!
  modelName: String!
  entityName: String
  bucketName: String
  description: String
  clientMutationId: String
}

type AddFilesPayload {
  files(before: String, after: String, first: Int, last: Int): FileConnection
  clientMutationId: String
}

input AddUserToOrganizationInput {
  userName: String!
  teams: [String!]
  organizationId: ID!
  userOrgRole: String!
  clientMutationId: String
}

type AddUserToOrganizationPayload {
  success: Boolean!
  clientMutationId: String
}

type Agent implements Node {
  id: ID!
  name: String!
  state: String

  """TODO: enum?"""
  host: String!
  persistent: Boolean

  """TODO: non-null?"""
  sweep: Sweep!
  user: User
  metrics: JSONString!
  createdAt: DateTime!
  heartbeatAt: DateTime
  displayName: String
  totalRuns: Int!
  runs(order: String, before: String, after: String, first: Int, last: Int): RunConnection!
}

type AgentConnection {
  pageInfo: PageInfo!
  edges: [AgentEdge!]!
}

type AgentEdge {
  node: Agent!
  cursor: String!
}

input AgentHeartbeatInput {
  id: ID!
  metrics: JSONString
  runState: JSONString
  clientMutationId: String
}

type AgentHeartbeatPayload {
  agent: Agent
  commands: JSONString
  clientMutationId: String
}

enum Aggregation {
  MAX
  MIN
  AVERAGE
  SUM
}

input AggregationKey {
  key: String!
  aggregation: Aggregation!
}

type Alert {
  id: ID!
  condition: AlertCondition!
  subscriptions: [AlertSubscription!]!
  events(from: DateTime!, to: DateTime, order: String, before: String, after: String, first: Int, last: Int): AlertEventConnection!
}

union AlertCondition = FinishedRunCondition | StoppedRunCondition | ScriptableRunCondition

type AlertEvent {
  id: ID!
  createdAt: DateTime!
}

type AlertEventConnection {
  pageInfo: PageInfo!
  edges: [AlertEventEdge!]!
}

type AlertEventEdge {
  node: AlertEvent
  cursor: String!
}

enum AlertSeverity {
  INFO
  WARN
  ERROR
}

interface AlertSubscription {
  id: ID!
}

type ApiKey {
  ips: [String!]!
  rateLimit: String
  user: User
  description: String
  id: ID!
  name: String!
}

type ApiKeyConnection {
  pageInfo: PageInfo!
  edges: [ApiKeyEdge!]!
}

type ApiKeyEdge {
  node: ApiKey
  cursor: String!
}

type Artifact {
  id: ID!
  digest: String!
  description: String
  commitHash(artifactCollectionName: String): String
  versionIndex(artifactCollectionName: String): Int
  aliases(artifactCollectionName: String): [ArtifactAlias!]!
  labels: JSONString
  metadata: JSONString
  state: ArtifactState!
  size: Int64!
  storageBytes: Int64!
  fileCount: Int64!
  artifactType: ArtifactType!
  artifactCollections: ArtifactCollectionConnection!
  artifactMemberships: ArtifactCollectionMembershipConnection!
  artifactSequence: ArtifactSequence!
  artifactActions(before: String, after: String, first: Int, last: Int): ArtifactActionConnection @deprecated
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: Initiator!
  usedCount: Int!
  usedBy(filters: JSONString, order: String, before: String, after: String, first: Int, last: Int): RunConnection!
  currentManifest: ArtifactManifest
  files(names: [String!], contentType: [String!], before: String, after: String, first: Int, last: Int): FileConnection!
  historyStep: Int64
}

interface ArtifactAction {
  id: ID!
  createdAt: DateTime!
  artifact: Artifact!
  initiator: Initiator!
}

type ArtifactActionConnection {
  pageInfo: PageInfo!
  edges: [ArtifactActionEdge!]!
}

type ArtifactActionEdge {
  node: ArtifactAction!
  cursor: String!
}

type ArtifactAlias {
  id: ID!
  artifact: Artifact
  artifactCollection: ArtifactCollection
  artifactCollectionName: String!
  alias: String!
}

type ArtifactAliasAction {
  alias: String!
  actionType: String!
  artifactCollection: ArtifactCollection!
  sourceArtifact: Artifact
  targetArtifact: Artifact
  createdAt: DateTime!
  user: User
}

type ArtifactAliasActionConnection {
  pageInfo: PageInfo!
  edges: [ArtifactAliasActionEdge!]!
}

type ArtifactAliasActionEdge {
  node: ArtifactAliasAction!
  cursor: String!
}

type ArtifactAliasConnection {
  pageInfo: PageInfo!
  edges: [ArtifactAliasEdge!]!
}

type ArtifactAliasEdge {
  node: ArtifactAlias
  cursor: String!
}

input ArtifactAliasInput {
  artifactCollectionName: String!
  alias: String!
}

interface ArtifactCollection {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  project: Project!
  state: ArtifactCollectionState!
  updatedAt: DateTime
  defaultArtifactType: ArtifactType!
  artifactCollectionActions(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): ArtifactCollectionActionConnection!
  aliasActionHistory(before: String, after: String, first: Int, last: Int, order: String, alias: String): ArtifactAliasActionConnection!
  artifactActions(before: String, after: String, first: Int, last: Int): ArtifactActionConnection @deprecated
  artifacts(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): VersionedArtifactConnection
  aliases(before: String, after: String, first: Int, last: Int): ArtifactAliasConnection!
  artifactMemberships(before: String, after: String, first: Int, last: Int): ArtifactCollectionMembershipConnection!
  artifactMembership(aliasName: String!): ArtifactCollectionMembership
}

type ArtifactCollectionAction {
  id: ID!
  createdAt: DateTime!
  artifact: Artifact
  artifactCollection: ArtifactCollection
  user: User
  actionType: String!
}

type ArtifactCollectionActionConnection {
  pageInfo: PageInfo!
  edges: [ArtifactCollectionActionEdge!]!
}

type ArtifactCollectionActionEdge {
  node: ArtifactCollectionAction!
  cursor: String!
}

input ArtifactCollectionAliasInput {
  alias: String!
  entityName: String!
  projectName: String!
  artifactCollectionName: String!
}

type ArtifactCollectionConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArtifactCollectionEdge!]!
}

type ArtifactCollectionEdge {
  node: ArtifactCollection
  cursor: String!
}

type ArtifactCollectionMembership {
  id: ID!
  artifactCollection: ArtifactCollection
  artifact: Artifact
  createdAt: DateTime!
  commitHash: String
  versionIndex: Int
  aliases: [ArtifactAlias!]!
}

type ArtifactCollectionMembershipConnection {
  pageInfo: PageInfo!
  edges: [ArtifactCollectionMembershipEdge!]!
}

type ArtifactCollectionMembershipEdge {
  node: ArtifactCollectionMembership
  cursor: String!
}

enum ArtifactCollectionState {
  READY
  DELETED
}

enum ArtifactCollectionType {
  SEQUENCE
  PORTFOLIO
}

type ArtifactConnection implements ArtifactConnectionType {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArtifactEdge!]!
}

interface ArtifactConnectionType {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArtifactEdgeType!]!
}

"""deprecated"""
enum ArtifactDigestAlgorithm {
  MANIFEST_MD5
}

type ArtifactEdge implements ArtifactEdgeType {
  node: Artifact
  cursor: String!
}

interface ArtifactEdgeType {
  node: Artifact
  cursor: String!
}

type ArtifactManifest {
  id: ID!
  type: ArtifactManifestType!
  createdAt: DateTime!
  digest: String!
  artifact: Artifact!
  file: File!
}

type ArtifactManifestConnection {
  pageInfo: PageInfo!
  edges: [ArtifactManifestEdge!]!
}

type ArtifactManifestEdge {
  node: ArtifactManifest
  cursor: String!
}

enum ArtifactManifestType {
  FULL
  PATCH
  INCREMENTAL
}

type ArtifactPortfolio implements ArtifactCollection {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  project: Project!
  state: ArtifactCollectionState!
  updatedAt: DateTime
  defaultArtifactType: ArtifactType!
  artifactCollectionActions(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): ArtifactCollectionActionConnection!
  aliasActionHistory(before: String, after: String, first: Int, last: Int, order: String, alias: String): ArtifactAliasActionConnection!
  artifactActions(before: String, after: String, first: Int, last: Int): ArtifactActionConnection! @deprecated
  artifacts(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): VersionedArtifactConnection!
  aliases(before: String, after: String, first: Int, last: Int): ArtifactAliasConnection!
  artifactMemberships(before: String, after: String, first: Int, last: Int): ArtifactCollectionMembershipConnection!
  artifactMembership(aliasName: String!): ArtifactCollectionMembership
}

type ArtifactSequence implements ArtifactCollection {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  project: Project!
  state: ArtifactCollectionState!
  updatedAt: DateTime
  defaultArtifactType: ArtifactType!
  artifactCollectionActions(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): ArtifactCollectionActionConnection!
  aliasActionHistory(before: String, after: String, first: Int, last: Int, order: String, alias: String): ArtifactAliasActionConnection!
  artifactActions(before: String, after: String, first: Int, last: Int): ArtifactActionConnection! @deprecated
  latestArtifact: Artifact
  artifacts(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): VersionedArtifactConnection!
  aliases(before: String, after: String, first: Int, last: Int): ArtifactAliasConnection!
  artifactMemberships(before: String, after: String, first: Int, last: Int): ArtifactCollectionMembershipConnection!

  """
  aliasName can be an alias (latest, v0, custom_alias), commitHash, or digest
  """
  artifactMembership(aliasName: String!): ArtifactCollectionMembership
}

type ArtifactSequenceConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArtifactSequenceEdge!]!
}

type ArtifactSequenceEdge {
  node: ArtifactSequence
  cursor: String!
}

type ArtifactSequenceStorageNode implements StorageTreeNode {
  id: ID!
  name: String!
  size: Int64!
  artifactSequence: ArtifactSequence!
  artifactType: ArtifactType!
  artifactSequenceID: ID!
  artifacts(before: String, after: String, first: Int, last: Int): ArtifactStorageNodeConnection!
}

type ArtifactSequenceStorageNodeConnection {
  totalSize: Int64!
  pageInfo: PageInfo!
  edges: [ArtifactSequenceStorageNodeEdge!]!
}

type ArtifactSequenceStorageNodeEdge {
  node: ArtifactSequenceStorageNode!
  cursor: String!
}

enum ArtifactState {
  PENDING
  COMMITTED
  DELETED
}

enum ArtifactStorageLayout {
  V1
  V2
}

type ArtifactStorageNode implements StorageTreeNode {
  id: ID!
  name: String!
  size: Int64!
  artifact: Artifact!
  artifactID: ID!
}

type ArtifactStorageNodeConnection {
  totalSize: Int64!
  pageInfo: PageInfo!
  edges: [ArtifactStorageNodeEdge!]!
}

type ArtifactStorageNodeEdge {
  node: ArtifactStorageNode!
  cursor: String!
}

type ArtifactType {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  project: Project!
  artifactActions(before: String, after: String, first: Int, last: Int): ArtifactActionConnection
  artifact(name: String!): Artifact
  artifactCollection(name: String!): ArtifactCollection
  artifactCollections(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString, collectionTypes: [ArtifactCollectionType!]): ArtifactCollectionConnection
  artifactSequence(name: String!): ArtifactSequence

  """legacy: prefer artifactCollection"""
  artifactSequences(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): ArtifactSequenceConnection
}

type ArtifactTypeConnection {
  pageInfo: PageInfo!
  edges: [ArtifactTypeEdge!]!
}

type ArtifactTypeEdge {
  node: ArtifactType
  cursor: String!
}

type BenchmarkRun {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  state: String!
  details: JSON
  results: String
  user: User!
  benchmark: Project!
  run: Run!
  originalProject: Project
  originalRun: Run
  isCodeHidden: Boolean!
  gitHubSubmissionPR: String
}

type BenchmarkRunConnection {
  pageInfo: PageInfo!
  edges: [BenchmarkRunEdge!]!
}

type BenchmarkRunEdge {
  node: BenchmarkRun
  cursor: String!
}

type BucketStoreConnectionError implements Error {
  message: String!
  severity: ErrorSeverity!
}

"""
This exists for legacy queries that spread fragments on BucketType.
Nothing new should be added here
"""
interface BucketType {
  id: ID!
  name: String
  config(keys: [String!]): JSONString
  framework: String
  description: String
  createdAt: DateTime!
  github: String
  commit: String
  host: String
  state: String
  shouldStop: Boolean
  summaryMetrics(keys: [String!], packVersion: Int): JSONString
  history(samples: Int, minStep: Int64, maxStep: Int64): [String!]!
  sweep: Sweep
  exampleTableColumns: JSONString
  exampleTableTypes: JSONString
  exampleTable: JSONString
  fileCount: Int
  logLines(before: String, after: String, first: Int, last: Int): LogLineConnection
  files(pattern: String, names: [String], contentType: [String!], before: String, after: String, first: Int, last: Int): FileConnection
}

input CancelCustomerSubscriptionInput {
  organizationId: ID!
  clientMutationId: String
}

type CancelCustomerSubscriptionPayload {
  success: Boolean
  clientMutationId: String
}

input ClaimAnonymousEntityInput {
  anonymousApiKey: String!
  clientMutationId: String
}

type ClaimAnonymousEntityPayload {
  task: Task!
  clientMutationId: String
}

type ClientIDMapping {
  clientID: ID!
  serverID: ID!
  entry: ClientIDMappingEntry!
}

union ClientIDMappingEntry = Artifact | ArtifactSequence

input CloneProjectsInput {
  projectNames: [String!]
  sourceEntityName: String!
  destinationEntityName: String!
  ownerUsername: String!
  notes: String
  clientMutationId: String
}

type CloneProjectsPayload {
  tasks: [Task!]!
  clientMutationId: String
}

enum CloudProvider {
  AWS
  GCP
  AZURE
  MINIO
}

type CloudRegion {
  id: ID!
  provider: CloudProvider!
  region: String!
}

type Code {
  name: String!
  body: String
  directUrl: String!
}

input CommitArtifactInput {
  artifactID: ID!
  clientMutationId: String
}

type CommitArtifactPayload {
  artifact: Artifact!
  clientMutationId: String
}

input ContactUsForComputeHoursInput {
  clientMutationId: String
}

type ContactUsForComputeHoursPayload {
  clientMutationId: String
}

input ContactUsForUserLedTrialInput {
  clientMutationId: String
}

type ContactUsForUserLedTrialPayload {
  clientMutationId: String
}

input CopyFileInput {
  id: ID!
  projectName: String!
  entityName: String!
  runName: String!
  clientMutationId: String
}

type CopyFilePayload {
  clientMutationId: String
}

input CreateAccessTokenInput {
  projects: [ProjectSpecifier!]!
  viewId: ID!
  email: String
  username: String
  clientMutationId: String
}

type CreateAccessTokenPayload {
  accessToken: AccessToken!
  toNewUser: Boolean
  recipientAlreadyOnTeam: Boolean
  clientMutationId: String
}

input CreateAgentInput {
  host: String!
  entityName: String
  projectName: String
  sweep: String!
  displayName: String
  clientMutationId: String
}

type CreateAgentPayload {
  agent: Agent
  clientMutationId: String
}

type CreateAlertPayload {
  alert: Alert!
  clientMutationId: String
}

input CreateAnonymousEntityInput {
  clientMutationId: String
}

type CreateArtifactCollectionPayload {
  artifactCollection: ArtifactCollection!
  clientMutationId: String
}

input CreateArtifactFilesInput {
  artifactFiles: [CreateArtifactFileSpecInput!]!
  storageLayout: ArtifactStorageLayout! = V1
  cloudRegionID: ID
  clientMutationId: String
}

type CreateArtifactFilesPayload {
  files(before: String, after: String, first: Int, last: Int): FileConnection!
  clientMutationId: String
}

input CreateArtifactFileSpecInput {
  artifactID: ID!
  name: String!
  md5: String!
  mimetype: String
  artifactManifestID: ID
}

input CreateArtifactInput {
  entityName: String!
  projectName: String!
  artifactTypeName: String!
  artifactCollectionName: String
  artifactCollectionNames: [String!]

  """deprecated"""
  runName: String
  digest: String!
  digestAlgorithm: ArtifactDigestAlgorithm!
  description: String
  labels: JSONString
  aliases: [ArtifactAliasInput!]
  metadata: JSONString
  historyStep: Int64
  enableDigestDeduplication: Boolean = false
  distributedID: String
  clientID: ID
  sequenceClientID: ID
  clientMutationId: String
}

input CreateArtifactManifestInput {
  artifactID: ID!
  baseArtifactID: ID
  name: String!
  digest: String!
  entityName: String!
  projectName: String!
  runName: String!
  type: ArtifactManifestType! = FULL
  clientMutationId: String
}

type CreateArtifactManifestPayload {
  artifactManifest: ArtifactManifest!
  clientMutationId: String
}

type CreateArtifactPayload {
  artifact: Artifact!
  artifactActions: [ArtifactAction!]!
  clientMutationId: String
}

input CreateArtifactPortfolioInput {
  entityName: String!
  projectName: String!
  artifactTypeID: ID!
  name: String!
  description: String
  clientMutationId: String
}

input CreateArtifactSequenceInput {
  entityName: String!
  projectName: String!
  artifactTypeID: ID!
  name: String!
  description: String
  clientMutationId: String
}

input CreateArtifactTypeInput {
  entityName: String!
  projectName: String!
  name: String!
  description: String
  clientMutationId: String
}

type CreateArtifactTypePayload {
  artifactType: ArtifactType!
  clientMutationId: String
}

input CreateAWSExternalIDInput {
  organizationID: ID
  clientMutationID: String
}

input CreateBenchmarkDiscussionCommentInput {
  discussionThreadID: ID!
  parentCommentID: ID
  body: String!
  clientMutationId: String
}

input CreateBenchmarkDiscussionThreadInput {
  benchmarkEntityName: String!
  benchmarkProjectName: String!
  title: String!
  body: String
  clientMutationId: String
}

input CreateClientIDMappingInput {
  clientID: ID!
  serverID: ID!
  clientMutationId: String
}

type CreateClientIDMappingPayload {
  clientIDMapping: ClientIDMapping!
  clientMutationId: String
}

input CreateCustomChartInput {
  entity: String!

  """gorilla.ValidateCustomChartName"""
  name: String!
  displayName: String!
  type: String!
  access: String!
  spec: JSONString!
  clientMutationId: String
}

type CreateCustomChartPayload {
  chart: CustomChart!
  clientMutationId: String
}

input CreateCustomerSubscriptionInput {
  planId: ID!
  newOrganizationName: String!
  paymentMethod: String!
  quantity: Int!
  trial: Boolean!
  clientMutationId: String
}

type CreateCustomerSubscriptionPayload {
  subscription: JSON
  clientMutationId: String
  organizationId: ID!
}

input CreateCustomerTrialInput {
  userName: String!
  planId: ID!
  newOrganizationName: String!
  quantity: Int!
  trialDays: Int!
  clientMutationId: String
}

type CreateCustomerTrialPayload {
  subscription: JSON
  clientMutationId: String
}

input CreateDefaultResourceConfigInput {
  entityName: String!
  projectName: String
  resource: String!
  config: JSONString!
  clientMutationId: String
}

type CreateDefaultResourceConfigPayload {
  success: Boolean!
  defaultResourceConfigID: ID!
  clientMutationId: String
}

type CreateDiscussionCommentPayload {
  discussionComment: DiscussionComment!
  clientMutationId: String
}

type CreateDiscussionThreadPayload {
  discussionThread: DiscussionThread!
  clientMutationId: String
}

input CreateEmailSubscriptionInput {
  alertID: ID!
  clientMutationId: String
}

type CreateEmailSubscriptionPayload {
  subscription: EmailSubscription!
  clientMutationId: String
}

input CreateEntityInput {
  name: String!

  """allows alphanumeric chars, hyphens, and underscores"""
  defaultFramework: String

  """deprecated"""
  invited: String
  defaultAccess: String
  clientMutationId: String
}

type CreateEntityPayload {
  entity: Entity
  apiKey: ApiKey
  clientMutationId: String
}

input CreateExperimentInput {
  name: String!
  variants: [VariantInput!]!
  experimentType: ExperimentType!
  metadata: JSONString
  sampleSize: Int!
  enrollmentPeriod: Int!
  observationalUnit: ObservationalUnit!
  clientMutationId: String
}

type CreateExperimentPayload {
  id: ID!
  success: Boolean!
  clientMutationId: String
}

input CreateFilterTriggerInput {
  name: String!
  description: String
  triggeringEventType: EventTriggeringConditionType!
  scopeType: TriggerScopeType!
  scopeID: ID!
  eventFilter: JSONString!
  triggeredActionType: TriggeredActionType!
  triggeredActionConfig: TriggeredActionConfig!
  enabled: Boolean!
  clientMutationId: String
}

type CreateFilterTriggerPayload {
  trigger: Trigger
  clientMutationId: String
}

input CreateFinishedRunAlertInput {
  entityName: String!
  projectName: String
  clientMutationId: String
}

input CreateGitHubOAuthIntegrationInput {
  code: String!
  entityName: String!
  redirectURI: String!
  state: String!
  clientMutationId: String
}

type CreateIntegrationPayload {
  integration: Integration!
  clientMutationId: String
}

input CreateInviteInput {
  username: String
  email: String
  entityName: String
  accountType: String

  """deprecated"""
  admin: Boolean
  role: String
  addSeat: Boolean
  clientMutationId: String
}

type CreateInvitePayload {
  invite: Invite
  success: Boolean!
  remainingSeats: Int
  remainingViewOnlySeats: Int
  clientMutationId: String
}

input CreateLaunchAgentInput {
  entityName: String!
  projectName: String!
  runQueues: [ID!]!
  hostname: String!
  clientMutationId: String
}

type CreateLaunchAgentPayload {
  success: Boolean
  launchAgentId: ID!
  clientMutationId: String
}

input CreateLocalLicenseOrganizationInput {
  newOrganizationName: String!
  clientMutationId: String
}

type CreateLocalLicenseOrganizationPayload {
  organization: Organization!
  clientMutationId: String
}

input CreateNewsletterSubscriptionInput {
  email: String
  clientMutationId: String
}

type CreateNewsletterSubscriptionPayload {
  newsletterSubscription: NewsletterSubscription!
  clientMutationId: String
}

input CreateRunQueueInput {
  entityName: String!
  projectName: String!
  queueName: String!
  access: RunQueueAccessType!
  defaultResourceConfigID: ID
  clientMutationId: String
}

type CreateRunQueuePayload {
  success: Boolean
  queueID: ID
  clientMutationId: String
}

input CreateScriptableRunAlertInput {
  entityName: String!
  projectName: String
  clientMutationId: String
}

input CreateServiceAccountInput {
  description: String
  entityName: String
  clientMutationId: String
}

type CreateServiceAccountPayload {
  user: User
  clientMutationId: String
}

input CreateSlackChannelSubscriptionInput {
  alertID: ID!
  integrationID: ID!
  clientMutationId: String
}

type CreateSlackChannelSubscriptionPayload {
  subscription: SlackChannelSubscription!
  clientMutationId: String
}

input CreateSlackIntegrationInput {
  code: String!
  entityName: String!
  redirectURI: String!
  clientMutationId: String
}

input CreateStoppedRunAlertInput {
  entityName: String!
  projectName: String
  minimumRunDuration: Duration!
  clientMutationId: String
}

input CreateStorageSubscriptionInput {
  storagePlanId: ID!
  trackingPlanId: ID!
  organizationId: ID
  paymentMethod: String
  trial: Boolean = false
  clientMutationId: String
}

type CreateStorageSubscriptionPayload {
  subscription: JSON
  clientMutationId: String
}

input CreateTeamInput {
  teamName: String!

  """new team name, allows alphanumeric chars, hyphens, and underscores"""
  teamAdminUserName: String

  """Optionally, user name of the admin. Defaults to auth user."""
  organizationId: String

  """Optionally, the organization this team belongs to."""
  defaultAccess: String
  storageBucketInfo: StorageBucketInfoInput
  clientMutationId: String
}

type CreateTeamPayload {
  entity: Entity
  clientMutationId: String
}

input CreateUserEmailInput {
  email: String!
  type: EmailType!
}

type CreateUserEmailPayload {
  success: Boolean!
  email: Email
}

input CreateUserInput {
  email: String!
  admin: Boolean
  password: String
  clientMutationId: String
}

input CreateUserLedTrialInput {
  newOrganizationName: String!
  newTeamName: String!
  orgSize: String!
  isAcademic: Boolean!
  allowJoinMatchingEmailDomain: Boolean
  justification: String
  storageBucketInfo: StorageBucketInfoInput
  clientMutationId: String
}

type CreateUserLedTrialPayload {
  subscription: JSON
  clientMutationId: String
}

type CreateUserPayload {
  user: User
  clientMutationId: String
}

input CreateViewCommentsAlertSubscriptionInput {
  viewID: ID!
  clientMutationId: String
}

input CreateViewDiscussionCommentInput {
  viewID: ID!
  discussionThreadID: ID
  body: String!
  notifyAllSubscribers: Boolean = false
  inlineCommentDetails: JSONString
  clientMutationId: String
}

type CreateViewDiscussionCommentPayload {
  discussionThread: DiscussionThread!
  discussionComment: DiscussionComment!
  alertSubscription: AlertSubscription!
  clientMutationId: String
}

type CustomChart {
  id: ID!
  entity: Entity!
  name: String!
  displayName: String!
  type: String!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime
  access: String!
  spec: JSONString!
}

type CustomChartConnection {
  pageInfo: PageInfo!
  edges: [CustomChartEdge!]!
}

type CustomChartEdge {
  node: CustomChart!
  cursor: String!
}

scalar DateTime

type DefaultResourceConfig {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  scope: DefaultResourceConfigScope!
  resource: String!
  config: JSON
}

type DefaultResourceConfigConnection {
  pageInfo: PageInfo!
  edges: [DefaultResourceConfigEdge!]!
}

type DefaultResourceConfigEdge {
  node: DefaultResourceConfig!
  cursor: String!
}

type DefaultResourceConfigScope {
  Type: DefaultResourceConfigScopeType!
  ID: Int!
}

enum DefaultResourceConfigScopeType {
  PROJECT
  ENTITY
}

input DeleteAlertInput {
  id: ID!
  clientMutationId: String
}

type DeleteAlertPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteAlertSubscriptionInput {
  id: ID!
  clientMutationId: String
}

type DeleteAlertSubscriptionPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteAliasesInput {
  aliases: [ArtifactCollectionAliasInput!]!
  artifactID: ID!
  clientMutationId: String
}

type DeleteAliasesPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteApiKeyInput {
  id: String
  clientMutationId: String
}

type DeleteApiKeyPayload {
  success: Boolean
  clientMutationId: String
}

type DeleteArtifactAction implements ArtifactAction {
  id: ID!
  createdAt: DateTime!
  artifact: Artifact!
  initiator: Initiator!
}

type DeleteArtifactCollectionPayload {
  artifactCollection: ArtifactCollection!
  clientMutationId: String
}

input DeleteArtifactInput {
  artifactID: ID!
  deleteAliases: Boolean = false
  clientMutationId: String
}

type DeleteArtifactPayload {
  artifact: Artifact!
  clientMutationId: String
}

input DeleteArtifactPortfolioInput {
  artifactPortfolioID: ID!
  clientMutationId: String
}

input DeleteArtifactSequenceInput {
  artifactSequenceID: ID!
  clientMutationId: String
}

input DeleteCustomChartInput {
  entity: String!
  name: String!
  clientMutationId: String
}

type DeleteCustomChartPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteDefaultResourceConfigsInput {
  defaultResourceConfigIDs: [ID!]!
  clientMutationId: String
}

type DeleteDefaultResourceConfigsPayload {
  success: Boolean!
  numAffected: Int64!
  clientMutationId: String
}

input DeleteDiscussionCommentInput {
  id: ID!
  deleteThread: Boolean = false
  clientMutationId: String
}

type DeleteDiscussionCommentPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteEntityInput {
  name: String!
  clientMutationId: String
}

type DeleteEntityPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteExperimentInput {
  id: ID!
  clientMutationId: String
}

type DeleteExperimentPayload {
  id: ID!
  success: Boolean!
  clientMutationId: String
}

input DeleteFilesInput {
  files: [ID!]!
  clientMutationId: String
}

type DeleteFilesPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteFromRunQueueInput {
  queueID: ID!
  runQueueItemId: ID!
  clientMutationId: String
}

type DeleteFromRunQueuePayload {
  success: Boolean
  clientMutationId: String
}

input DeleteIntegrationInput {
  id: ID!
  clientMutationId: String
}

type DeleteIntegrationPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteInviteInput {
  id: String
  entityName: String
  clientMutationId: String
}

type DeleteInvitePayload {
  success: Boolean
  clientMutationId: String
}

input DeleteLaunchAgentsInput {
  launchAgentIds: [ID!]!
  clientMutationId: String
}

type DeleteLaunchAgentsPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteModelInput {
  id: String!
  clientMutationId: String
}

type DeleteModelPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteNewsletterSubscriptionInput {
  id: ID!
  clientMutationId: String
}

type DeleteNewsletterSubscriptionPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteRunInput {
  id: ID!
  deleteArtifacts: Boolean = false
  clientMutationId: String
}

type DeleteRunPayload {
  clientMutationId: String
}

input DeleteRunQueuesInput {
  queueIDs: [ID!]!
  clientMutationId: String
}

type DeleteRunQueuesPayload {
  success: Boolean
  clientMutationId: String
}

input DeleteRunsInput {
  entityName: String!
  projectName: String!
  filters: JSONString!
  deleteArtifacts: Boolean = false
  clientMutationId: String
}

type DeleteRunsPayload {
  clientMutationId: String
  errors: String
}

input DeleteSweepInput {
  id: ID!
  deleteRuns: Boolean!
  clientMutationId: String
}

input DeleteSweepsInput {
  ids: [ID!]!
  deleteRuns: Boolean!
  clientMutationId: String
}

type DeleteSweepsPayload {
  affectedAgents: Int!
  affectedRuns: Int!
  clientMutationId: String
}

input DeleteTeamInput {
  teamName: String!
  clientMutationId: String
}

type DeleteTeamPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteTriggerInput {
  triggerID: ID!
  clientMutationId: String
}

type DeleteTriggerPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteUserEmailInput {
  id: ID!
}

type DeleteUserEmailPayload {
  success: Boolean!
  email: Email
}

input DeleteUserInput {
  id: ID!
  clientMutationId: String
}

type DeleteUserPayload {
  user: User
  clientMutationId: String
}

input DeleteViewInput {
  id: ID
  deleteDrafts: Boolean = false
  clientMutationId: String
}

type DeleteViewPayload {
  success: Boolean
  pendingDrafts: Boolean
  clientMutationId: String
}

input DeleteViewsInput {
  ids: [ID!]!
  deleteDrafts: Boolean = false
  clientMutationId: String
}

type DeleteViewsPayload {
  success: Boolean
  pendingDrafts: Boolean
  clientMutationId: String
}

enum DiffOperation {
  INSERT
  DELETE
  UPDATE
}

type DiscussionComment {
  id: ID!
  poster: User!
  parentComment: DiscussionComment
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  isParent: Boolean!
  upvotes: Int!
  body: String!
  childComments(before: String, after: String, first: Int, last: Int): DiscussionCommentConnection!
}

type DiscussionCommentConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DiscussionCommentEdge!]!
}

type DiscussionCommentEdge {
  node: DiscussionComment!
  cursor: String!
}

type DiscussionThread {
  id: ID!
  poster: User!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  upvotes: Int!
  title: String!
  body: String!
  comments(before: String, after: String, first: Int, last: Int): DiscussionCommentConnection!
}

type DiscussionThreadConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DiscussionThreadEdge!]!
}

type DiscussionThreadEdge {
  node: DiscussionThread!
  cursor: String!
}

enum DotBehavior {
  KEEP_ALL_DOT_VALUES
  SKIP_FIRST_DOT_VALUE
}

scalar Duration

type Email {
  id: ID!
  emailAddress: String!
  type: EmailType!
  createdAt: DateTime!
  identities: [Identity!]!
  verified: Boolean!
}

type EmailSubscription implements AlertSubscription {
  id: ID!
}

enum EmailType {
  PERSONAL
  CORPORATE
  ACADEMIC
}

type Entity implements Node {
  createdAt: DateTime!
  updatedAt: DateTime
  id: ID!
  name: String!
  profileView: View
  photoUrl: String
  photoUploadUrl: String!
  uploadHeaders: [String!]!
  subscriptionId: Int
  defaultAccess: String!
  privateOnly: Boolean!
  codeSavingEnabled: Boolean!
  isTeam: Boolean!
  projects(before: String, after: String, first: Int, last: Int, order: String): ProjectConnection
  runs(order: String, before: String, after: String, first: Int, last: Int): RunConnection
  latestRuns: RunConnection
  limits: JSONString
  available: Boolean
  invites(keysOnly: Boolean, batchSize: Int, pageSize: Int, before: String, after: String, first: Int, last: Int): InviteConnection
  members: [Member!]!
  memberCount: Int!
  invitedTeam: String
  readOnly: Boolean
  readOnlyAdmin: Boolean!
  runCount(filters: JSONString): Int!
  user: User
  storageBytes: Int64!
  referenceBytes: Int64!
  storageTree(enableReferenceTracking: Boolean = false): EntityStorageNode
  computeHours(minDaysOld: Int = 0): Duration!
  userStats(from: DateTime!, to: DateTime, before: String, after: String, filters: JSONString, first: Int, last: Int, order: String): EntityUserConnection
  integrations(before: String, after: String, first: Int, last: Int): IntegrationConnection
  defaultAlerts: [Alert!]!
  dailyRunCount(limit: Int!): [Int!]!
  claimingEntity: Entity
  claimedEntities(before: String, after: String, first: Int, last: Int): EntityConnection
  isPaid: Boolean
  rateLimits: RateLimits
  settings: EntitySettings!
  accessTokens: [AccessToken!]!
  organizationId: ID
  organization: Organization
  repos(before: String, after: String, first: Int, last: Int): RepoConnection
  artifactCollections(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString, collectionTypes: [ArtifactCollectionType!]): ArtifactCollectionConnection
  defaultResourceConfigs(before: String, after: String, first: Int, last: Int): DefaultResourceConfigConnection
  defaultResourceConfig(id: ID!): DefaultResourceConfig
}

type EntityConnection {
  edges: [EntityEdge!]!
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntitySettings {
  defaultCloudRegion: CloudRegion!
  openToMatchingOrgEmailDomainUsers: Boolean
  storageBucketInfo: StorageBucketInfo
  entityProfileEnabled: Boolean!
}

input EntitySettingsInput {
  defaultCloudRegionID: String
  openToMatchingOrgEmailDomainUsers: Boolean
  entityProfileEnabled: Boolean
}

type EntityStorageNode implements StorageTreeNode {
  id: ID!
  name: String!
  size: Int64!
  entity: Entity!
  entityID: ID!
  projects(before: String, after: String, first: Int, last: Int): ProjectStorageNodeConnection!
}

type EntityUser implements Node {
  id: ID!
  user: User!
  runCount: Int!
}

type EntityUserConnection {
  """pageInfo: PageInfo!"""
  edges: [EntityUserEdge!]!
}

type EntityUserEdge {
  node: EntityUser
  cursor: String!
}

interface Error {
  message: String!
}

enum ErrorSeverity {
  WARN
  ERROR
}

type Event {
  id: String
  name: String
  description: String
  url: String
  kind: String
  state: String
  extra: String
  user: User
  projectName: String
  entityName: String
  createdAt: DateTime
}

type EventConnection {
  """pageInfo: PageInfo!"""
  edges: [EventEdge!]!
}

type EventEdge {
  node: Event
  cursor: String!
}

"""| Entity"""
enum EventTriggeringConditionType {
  CREATE_ARTIFACT
  UPDATE_ARTIFACT_ALIAS
  LINK_MODEL
}

type Experiment implements Node {
  id: ID!
  name: String!
  variants: [Variant!]!
  experimentType: ExperimentType!
  startAt: DateTime
  endAt: DateTime
  updatedAt: DateTime!
  metadata: JSON
  observationalUnit: ObservationalUnit!
  sampleSize: Int!
  enrollmentPeriod: Int!
}

enum ExperimentType {
  FEATURE_FLAG
  AB_TEST
}

type File implements Node {
  id: ID!
  name: String!
  displayName: String!
  archived: Boolean
  createdAt: DateTime
  deletedAt: DateTime
  storageBucket: String
  storagePath: String
  updatedAt: DateTime
  special: Boolean
  mimetype: String
  ndbId: ID @deprecated(reason: "Use id instead")
  sizeBytes: Int64!
  md5: String
  digest: String
  isReference: Boolean!
  exists: Boolean!
  url(upload: Boolean): String
  uploadUrl: String
  uploadHeaders: [String!]!
  directUrl: String!
  artifact: Artifact
}

type FileConnection {
  uploadHeaders: [String!]!
  pageInfo: PageInfo!
  edges: [FileEdge!]!
}

type FileEdge {
  node: File
  cursor: String!
}

type FileStorageNode implements StorageTreeNode {
  id: ID!
  name: String!
  size: Int64!
  file: File!
  fileID: ID!
}

type FileStorageNodeConnection {
  totalSize: Int64!
  pageInfo: PageInfo!
  edges: [FileStorageNodeEdge!]!
}

type FileStorageNodeEdge {
  node: FileStorageNode!
  cursor: String!
}

"""| CronTriggeringCondition"""
type FilterEventTriggeringCondition {
  eventType: EventTriggeringConditionType!
  filter: String!
}

type FinishedRunCondition {
  """GraphQL doesn't allow empty types, so this always returns true"""
  success: Boolean!
}

input GenerateApiKeyInput {
  description: String
  clientMutationId: String
}

type GenerateApiKeyPayload {
  apiKey: ApiKey
  clientMutationId: String
}

input GenerateLocalLicenseInput {
  contactEmail: String!
  customerName: String!
  seats: Int!
  teams: Int!
  storageGigs: Int!
  expDuration: Int!
  flags: [String!]!
  notes: String
  clientMutationId: String
}

type GenerateLocalLicensePayload {
  localLicense: LocalLicense!
  clientMutationId: String
}

type GitHubOAuthIntegration implements Integration {
  id: ID!
}

type GitInfo {
  remote: String
  commit: String
}

input GroupAggregation {
  default: Aggregation!
  custom: [AggregationKey!]!
}

enum HistoryKeysFormat {
  PLAINTEXT
  BITMAP
}

input HubSettingsInput {
  repo: String
  disk: String
  redisEnabled: Boolean
  dockerEnabled: Boolean
  image: String
}

type Identity {
  id: ID!
  emailIdentityVerified: Boolean!
  provider: String
}

type ImageUrl {
  url: String
  publicUrl: String
  path: String
}

union Initiator = Run | User

type InputArtifactConnection implements ArtifactConnectionType {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [InputArtifactEdge!]!
}

type InputArtifactEdge implements ArtifactEdgeType {
  node: Artifact
  cursor: String!
  usedAs: [String!]!
}

input InsertGalleryDiscussionInput {
  spec: String!
  reportID: ID!
  sendEmail: Boolean
  clientMutationId: String
}

type InsertGalleryDiscussionPayload {
  success: Boolean!
  clientMutationId: String
}

scalar Int64

interface Integration {
  id: ID!
}

type IntegrationConnection {
  pageInfo: PageInfo!
  edges: [IntegrationEdge!]!
}

type IntegrationEdge {
  node: Integration
  cursor: String!
}

type Invite {
  updatedAt: DateTime
  toUser: User
  expiresAt: DateTime
  fromUser: User
  accepted: Boolean
  createdAt: DateTime
  email: String
  entity: Entity
  organization: Organization
  id: ID!
  name: String!
}

type InviteConnection {
  pageInfo: PageInfo!
  edges: [InviteEdge!]!
}

type InviteEdge {
  node: Invite
  cursor: String!
}

scalar JSON

scalar JSONString

type LaunchAgent {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime
  runQueues: [ID!]!
  hostname: String!
  agentStatus: String!
  stopPolling: Boolean!
  heartbeatAt: DateTime
}

type LicenseClaims {
  seats: Int!
  teams: Int!
  storageGigs: Int!
  flags: [String!]!
  expiresAt: Int64!
}

type LicenseExpirationUI {
  bannerTotalDays: Int!
  bannerDaysRemaining: Int!
  renewUrl: String
}

input LinkArtifactInput {
  artifactID: ID
  artifactPortfolioID: ID
  artifactPortfolioName: String
  entityName: String
  projectName: String
  aliases: [ArtifactAliasInput!]
  clientID: ID
  clientMutationId: String
}

type LinkArtifactPayload {
  artifactCollectionID: ID!
  artifactID: ID!
  createdAt: DateTime!
  versionIndex: Int
  clientMutationId: String
}

input LinkTeamToOrganizationInput {
  entityName: String!
  organizationID: ID!
  clientMutationId: String
}

type LinkTeamToOrganizationPayload {
  success: Boolean!
  clientMutationId: String
}

type LocalLicense implements Node {
  id: ID!
  uid: String!
  license: String!
  customerName: String!
  contactEmail: String!
  generatedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime
  expiresAt: DateTime!
  claims: LicenseClaims!
  notes: String
}

type LocalVersionInfo {
  outOfDate: Boolean!
  latestVersionString: String!
  versionOnThisInstanceString: String!
}

type LogLine {
  line: String
  number: Int
  level: String
  timestamp: String
  id: String
}

type LogLineConnection {
  pageInfo: PageInfo!
  edges: [LogLineEdge!]!
}

type LogLineEdge {
  node: LogLine!
  cursor: String!
}

type Member {
  admin: Boolean @deprecated(reason: "Use `role` instead.")
  role: String
  pending: Boolean
  username: String
  name: String!
  email: String
  id: String
  accountType: String
  apiKey: String
  photoUrl: String
}

input ModifyRunsInput {
  ids: [String]

  """deprecated"""
  filters: JSONString
  entityName: String
  projectName: String
  addTags: [String]
  removeTags: [String]
  clientMutationId: String
}

type ModifyRunsPayload {
  runs: [Run]!
  runsSQL: [Run]!
  clientMutationId: String
}

type MoveArtifactAliasAction implements ArtifactAction {
  id: ID!
  createdAt: DateTime!
  artifact: Artifact!
  destinationArtifact: Artifact
  initiator: Initiator!
}

type MoveArtifactCollectionPayload {
  artifactCollection: ArtifactCollection
  clientMutationId: String
}

input MoveArtifactSequenceInput {
  artifactSequenceID: ID!
  destinationArtifactTypeName: String!
  clientMutationId: String
}

input MoveProjectsInput {
  projectNames: [String!]
  sourceEntityName: String!
  destinationEntityName: String!
  ownerUsername: String!
  notes: String
  clientMutationId: String
}

type MoveProjectsPayload {
  tasks: [Task!]!
  clientMutationId: String
}

input MoveRunsInput {
  filters: JSONString!
  sourceEntityName: String!
  sourceProjectName: String!
  destinationEntityName: String!
  destinationProjectName: String!
  clientMutationId: String
}

type MoveRunsPayload {
  task: Task!
  clientMutationId: String
}

input MoveViewInput {
  id: ID!
  entityName: String!
  projectName: String!
  clientMutationId: String
}

type MoveViewPayload {
  success: Boolean
  clientMutationId: String
}

type Mutation {
  deleteModel(input: DeleteModelInput!): DeleteModelPayload
  upsertModel(input: UpsertModelInput!): UpsertModelPayload
  renameProject(input: RenameProjectInput!): UpsertModelPayload
  deleteRun(input: DeleteRunInput!): DeleteRunPayload
  deleteRuns(input: DeleteRunsInput!): DeleteRunsPayload
  undeleteRuns(input: UndeleteRunsInput!): UndeleteRunsPayload
  upsertBucket(input: UpsertBucketInput!): UpsertBucketPayload
  upsertRunGroup(input: UpsertRunGroupInput!): UpsertRunGroupPayload
  upsertSweep(input: UpsertSweepInput!): UpsertSweepPayload
  createAgent(input: CreateAgentInput!): CreateAgentPayload
  agentHeartbeat(input: AgentHeartbeatInput!): AgentHeartbeatPayload

  """launchRun(input: LaunchRunInput!): LaunchRunPayload"""
  modifyRuns(input: ModifyRunsInput!): ModifyRunsPayload
  moveRuns(input: MoveRunsInput!): MoveRunsPayload
  stopRun(input: StopRunInput!): StopRunPayload

  """
  updateJob(input: UpdateJobInput!): UpdateJobPayload
  deleteBucket(input: DeleteBucketInput!): DeleteBucketPayload
  """
  addFiles(input: AddFilesInput!): AddFilesPayload
  deleteFiles(input: DeleteFilesInput!): DeleteFilesPayload
  copyFile(input: CopyFileInput!): CopyFilePayload
  createEntity(input: CreateEntityInput!): CreateEntityPayload
  createAnonymousEntity(input: CreateAnonymousEntityInput!): CreateEntityPayload
  deleteEntity(input: DeleteEntityInput!): DeleteEntityPayload
  updateSubscription(input: UpdateSubscriptionInput!): UpdateSubscriptionPayload
  createInvite(input: CreateInviteInput!): CreateInvitePayload
  deleteInvite(input: DeleteInviteInput!): DeleteInvitePayload
  createUser(input: CreateUserInput!): CreateUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(input: DeleteUserInput!): DeleteUserPayload
  undeleteUser(input: UndeleteUserInput!): UndeleteUserPayload
  purgeUser(input: PurgeUserInput!): PurgeUserPayload
  updateUserEmail(input: UpdateUserEmailInput!): UpdateUserEmailPayload
  deleteUserEmail(input: DeleteUserEmailInput!): DeleteUserEmailPayload
  updateEntity(input: UpdateEntityInput!): UpdateEntityPayload
  createServiceAccount(input: CreateServiceAccountInput!): CreateServiceAccountPayload
  generateApiKey(input: GenerateApiKeyInput!): GenerateApiKeyPayload
  deleteApiKey(input: DeleteApiKeyInput!): DeleteApiKeyPayload
  insertGalleryDiscussion(input: InsertGalleryDiscussionInput!): InsertGalleryDiscussionPayload
  submitFCProject(input: SubmitFCProjectInput!): SubmitFCProjectPayload
  upsertView(input: UpsertViewInput!): UpsertViewPayload
  moveView(input: MoveViewInput!): MoveViewPayload
  deleteView(input: DeleteViewInput!): DeleteViewPayload
  deleteViews(input: DeleteViewsInput!): DeleteViewsPayload
  starView(input: StarViewInput!): StarViewPayload
  unstarView(input: UnstarViewInput!): UnstarViewPayload

  """records a single view (page load) of a view (report)"""
  viewView(input: ViewViewInput!): ViewViewPayload
  upsertSharedView(input: UpsertSharedViewInput!): UpsertSharedViewPayload
  setTagColor(input: SetTagColorInput!): SetTagColorPayload

  """
  mutation to enable wandb admin to create teams given teamAdminUserName and new teamName
  """
  createTeam(input: CreateTeamInput!): CreateTeamPayload
  deleteTeam(input: DeleteTeamInput!): DeleteTeamPayload
  submitBenchmarkRun(input: SubmitBenchmarkRunInput!): SubmitBenchmarkRunPayload
  publishBenchmarkRun(input: PublishBenchmarkRunInput!): PublishBenchmarkRunPayload
  updateBenchmarkRun(input: UpdateBenchmarkRunInput!): UpdateBenchmarkRunPayload
  updateMember(input: UpdateMemberInput!): UpdateMemberPayload
  createFinishedRunAlert(input: CreateFinishedRunAlertInput!): CreateAlertPayload
  createStoppedRunAlert(input: CreateStoppedRunAlertInput!): CreateAlertPayload
  updateStoppedRunAlert(input: UpdateStoppedRunAlertInput!): UpdateAlertPayload
  createScriptableRunAlert(input: CreateScriptableRunAlertInput!): CreateAlertPayload
  deleteAlert(input: DeleteAlertInput!): DeleteAlertPayload
  notifyScriptableRunAlert(input: NotifyScriptableRunAlertInput!): NotifyScriptableRunAlertPayload
  createSlackChannelSubscription(input: CreateSlackChannelSubscriptionInput!): CreateSlackChannelSubscriptionPayload
  createEmailSubscription(input: CreateEmailSubscriptionInput!): CreateEmailSubscriptionPayload
  createViewCommentsAlertSubscription(input: CreateViewCommentsAlertSubscriptionInput!): CreateEmailSubscriptionPayload
  deleteAlertSubscription(input: DeleteAlertSubscriptionInput!): DeleteAlertSubscriptionPayload
  deleteSweep(input: DeleteSweepInput!): DeleteSweepsPayload
  deleteSweeps(input: DeleteSweepsInput!): DeleteSweepsPayload
  createSlackIntegration(input: CreateSlackIntegrationInput!): CreateIntegrationPayload
  createGitHubOAuthIntegration(input: CreateGitHubOAuthIntegrationInput!): CreateIntegrationPayload
  deleteIntegration(input: DeleteIntegrationInput!): DeleteIntegrationPayload
  createBenchmarkDiscussionThread(input: CreateBenchmarkDiscussionThreadInput!): CreateDiscussionThreadPayload
  createViewDiscussionComment(input: CreateViewDiscussionCommentInput!): CreateViewDiscussionCommentPayload
  updateDiscussionThread(input: UpdateDiscussionThreadInput!): UpdateDiscussionThreadPayload
  createBenchmarkDiscussionComment(input: CreateBenchmarkDiscussionCommentInput!): CreateDiscussionCommentPayload
  updateDiscussionComment(input: UpdateDiscussionCommentInput!): UpdateDiscussionCommentPayload
  deleteDiscussionComment(input: DeleteDiscussionCommentInput!): DeleteDiscussionCommentPayload
  claimAnonymousEntity(input: ClaimAnonymousEntityInput!): ClaimAnonymousEntityPayload
  createCustomerSubscription(input: CreateCustomerSubscriptionInput!): CreateCustomerSubscriptionPayload
  createStorageSubscription(input: CreateStorageSubscriptionInput!): CreateStorageSubscriptionPayload
  upgradeCustomerSubscription(input: UpgradeCustomerSubscriptionInput!): UpgradeCustomerSubscriptionPayload
  createCustomerTrial(input: CreateCustomerTrialInput!): CreateCustomerTrialPayload
  createUserLedTrial(input: CreateUserLedTrialInput!): CreateUserLedTrialPayload
  contactUsForUserLedTrial(input: ContactUsForUserLedTrialInput!): ContactUsForUserLedTrialPayload
  contactUsForComputeHours(input: ContactUsForComputeHoursInput!): ContactUsForComputeHoursPayload
  cancelCustomerSubscription(input: CancelCustomerSubscriptionInput!): CancelCustomerSubscriptionPayload
  updateCustomerPaymentMethod(input: UpdateCustomerPaymentMethodInput!): UpdateCustomerPaymentMethodPayload
  createLocalLicenseOrganization(input: CreateLocalLicenseOrganizationInput!): CreateLocalLicenseOrganizationPayload
  addUserToOrganization(input: AddUserToOrganizationInput!): AddUserToOrganizationPayload
  removeUserFromOrganization(input: RemoveUserFromOrganizationInput!): RemoveUserFromOrganizationPayload
  updateOrganization(input: UpdateOrganizationInput!): UpdateOrganizationPayload
  updateOrganizationUser(input: UpdateOrganizationUserInput!): UpdateOrganizationUserPayload
  updateOrganizationBillingUser(input: UpdateOrganizationBillingUserInput!): UpdateOrganizationBillingUserPayload
  linkTeamToOrganization(input: LinkTeamToOrganizationInput!): LinkTeamToOrganizationPayload
  createArtifactType(input: CreateArtifactTypeInput!): CreateArtifactTypePayload
  updateArtifactType(input: UpdateArtifactTypeInput!): UpdateArtifactTypePayload
  createArtifactSequence(input: CreateArtifactSequenceInput!): CreateArtifactCollectionPayload
  updateArtifactSequence(input: UpdateArtifactSequenceInput!): UpdateArtifactCollectionPayload
  moveArtifactSequence(input: MoveArtifactSequenceInput!): MoveArtifactCollectionPayload
  deleteArtifactSequence(input: DeleteArtifactSequenceInput!): DeleteArtifactCollectionPayload
  createArtifactPortfolio(input: CreateArtifactPortfolioInput!): CreateArtifactCollectionPayload
  updateArtifactPortfolio(input: UpdateArtifactPortfolioInput!): UpdateArtifactCollectionPayload
  deleteArtifactPortfolio(input: DeleteArtifactPortfolioInput!): DeleteArtifactCollectionPayload
  createArtifact(input: CreateArtifactInput!): CreateArtifactPayload
  updateArtifact(input: UpdateArtifactInput!): UpdateArtifactPayload
  useArtifact(input: UseArtifactInput!): UseArtifactPayload
  commitArtifact(input: CommitArtifactInput!): CommitArtifactPayload
  deleteArtifact(input: DeleteArtifactInput!): DeleteArtifactPayload
  linkArtifact(input: LinkArtifactInput!): LinkArtifactPayload
  unlinkArtifact(input: UnlinkArtifactInput!): UnlinkArtifactPayload
  addAliases(input: AddAliasesInput!): AddAliasesPayload
  deleteAliases(input: DeleteAliasesInput!): DeleteAliasesPayload
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
  createArtifactManifest(input: CreateArtifactManifestInput!): CreateArtifactManifestPayload
  updateArtifactManifest(input: UpdateArtifactManifestInput!): UpdateArtifactManifestPayload
  createArtifactFiles(input: CreateArtifactFilesInput!): CreateArtifactFilesPayload
  createRunQueue(input: CreateRunQueueInput!): CreateRunQueuePayload
  deleteRunQueues(input: DeleteRunQueuesInput!): DeleteRunQueuesPayload
  pushToRunQueue(input: PushToRunQueueInput!): PushToRunQueuePayload
  pushToRunQueueByName(input: PushToRunQueueByNameInput!): PushToRunQueueByNamePayload
  popFromRunQueue(input: PopFromRunQueueInput!): PopFromRunQueuePayload
  ackRunQueueItem(input: AckRunQueueItemInput!): AckRunQueueItemPayload
  deleteFromRunQueue(input: DeleteFromRunQueueInput!): DeleteFromRunQueuePayload
  createDefaultResourceConfig(input: CreateDefaultResourceConfigInput!): CreateDefaultResourceConfigPayload
  deleteDefaultResourceConfigs(input: DeleteDefaultResourceConfigsInput!): DeleteDefaultResourceConfigsPayload
  updateDefaultResourceConfig(input: UpdateDefaultResourceConfigInput!): UpdateDefaultResourceConfigPayload
  createLaunchAgent(input: CreateLaunchAgentInput!): CreateLaunchAgentPayload
  deleteLaunchAgents(input: DeleteLaunchAgentsInput!): DeleteLaunchAgentsPayload
  updateLaunchAgent(input: UpdateLaunchAgentInput!): UpdateLaunchAgentPayload
  createAccessToken(input: CreateAccessTokenInput!): CreateAccessTokenPayload
  revokeAccessToken(input: RevokeAccessTokenInput!): RevokeAccessTokenPayload
  updateAccessTokenProjects(input: UpdateAccessTokenProjectsInput!): UpdateAccessTokenProjectsPayload
  updateAccessToken(input: UpdateAccessTokenInput!): UpdateAccessTokenPayload
  revokeAccessTokenEmail(input: RevokeAccessTokenEmailInput!): RevokeAccessTokenEmailPayload
  createCustomChart(input: CreateCustomChartInput!): CreateCustomChartPayload
  updateCustomChart(input: UpdateCustomChartInput!): UpdateCustomChartPayload
  deleteCustomChart(input: DeleteCustomChartInput!): DeleteCustomChartPayload
  generateLocalLicense(input: GenerateLocalLicenseInput!): GenerateLocalLicensePayload
  updateOrganizationSubscription(input: UpdateOrganizationSubscriptionInput!): UpdateOrganizationSubscriptionPayload
  updateLocalLicense(input: UpdateLocalLicenseInput!): UpdateLocalLicensePayload
  moveProjects(input: MoveProjectsInput!): MoveProjectsPayload
  cloneProjects(input: CloneProjectsInput!): CloneProjectsPayload
  createNewsletterSubscription(input: CreateNewsletterSubscriptionInput!): CreateNewsletterSubscriptionPayload
  deleteNewsletterSubscription(input: DeleteNewsletterSubscriptionInput!): DeleteNewsletterSubscriptionPayload
  createClientIDMapping(input: CreateClientIDMappingInput!): CreateClientIDMappingPayload
  updateRampThreshold(input: UpdateRampThresholdInput!): UpdateRampThresholdPayload
  resendEmailVerification(input: ResendEmailVerificationInput!): ResendEmailVerificationPayload
  sendRequestOrgEmailDomainVerification(input: SendRequestOrgEmailDomainVerificationInput!): SendRequestOrgEmailDomainVerificationPayload
  createExperiment(input: CreateExperimentInput!): CreateExperimentPayload
  updateExperiment(input: UpdateExperimentInput!): UpdateExperimentPayload
  startExperiment(input: StartExperimentInput!): UpdateExperimentPayload
  stopExperiment(input: StopExperimentInput!): UpdateExperimentPayload
  deleteExperiment(input: DeleteExperimentInput!): DeleteExperimentPayload
  createFilterTrigger(input: CreateFilterTriggerInput!): CreateFilterTriggerPayload
  deleteTrigger(input: DeleteTriggerInput!): DeleteTriggerPayload
  createAWSExternalID(input: CreateAWSExternalIDInput!): String!
  testBucketStoreConnection(input: StorageBucketInfoInput!): [BucketStoreConnectionError!]!
}

type NewsletterSubscription {
  id: ID!
  user: User
  email: String
  createdAt: DateTime!
}

type NewsletterSubscriptionConnection {
  edges: [NewsletterSubscriptionEdge!]!
}

type NewsletterSubscriptionEdge {
  node: NewsletterSubscription
  cursor: String!
}

interface Node {
  id: ID!
}

input NotifyScriptableRunAlertInput {
  entityName: String!
  projectName: String!
  runName: String!
  title: String!
  text: String!
  severity: AlertSeverity = INFO
  waitDuration: Duration
  clientMutationId: String
}

type NotifyScriptableRunAlertPayload {
  success: Boolean!
  clientMutationId: String
}

enum ObservationalUnit {
  USER
  ANONYMOUS_USER
  ORGANIZATION
  TEAM
}

type Organization implements Node {
  id: ID!
  name: String!
  billingUser: User
  stripeBillingInfo: StripeBillingInfo
  members: [OrganizationMember!]!
  pendingInvites: [Invite!]!
  teams: [Entity!]!
  subscriptions: [OrganizationSubscription!]!
  orgType: OrgType!
  flags: JSONString
  available: Boolean!
  views(before: String, after: String, first: Int, last: Int, limit: Int, offset: Int, order: String): ViewConnection!
  artifactSequences(before: String, after: String, first: Int, last: Int, limit: Int, offset: Int, order: String, filters: JSONString): ArtifactSequenceConnection

  """legacy: prefer artifactCollections"""
  artifactCollections(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString, collectionTypes: [ArtifactCollectionType!]): ArtifactCollectionConnection
  projects(before: String, after: String, first: Int, last: Int, order: String): ProjectConnection
}

type OrganizationConnection {
  pageInfo: PageInfo!
  edges: [OrganizationEdge!]!
}

type OrganizationEdge {
  node: Organization!
  cursor: String!
}

type OrganizationMember {
  user: User!
  admin: Boolean!

  """pending: Boolean -- TODO will need this soon."""
  username: String!
  name: String!
  id: String!
  photoUrl: String!
  teams(before: String, after: String, first: Int, last: Int): EntityConnection
  role: String!
}

type OrganizationSubscription {
  id: ID!
  plan: Plan!
  privileges: JSON!
  seats: Int!
  subscriptionType: OrganizationSubscriptionType!
  status: OrganizationSubscriptionStatus!
  expiresAt: DateTime
}

enum OrganizationSubscriptionStatus {
  ENABLED
  DISABLED
}

enum OrganizationSubscriptionType {
  STRIPE
  ENTERPRISE
  MANUAL_TRIAL
  USER_LED_TRIAL
  ACADEMIC_TRIAL
  ACADEMIC
  LOCAL
}

enum OrgType {
  ORGANIZATION
  PERSONAL
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PaymentMethod {
  id: ID!
  type: String!
  cardType: String
  endingIn: String
}

type Plan {
  id: ID!
  name: String!
  displayName: String!
  stripePlanId: String
  maxSeats: Int!
  defaultPrivileges: JSON!
  planType: PlanType!
  planVisibility: PlanVisibility!
  unitPrice: Int
  billingInterval: String
}

enum PlanType {
  PRIMARY
  STORAGE
  REFERENCE
}

enum PlanVisibility {
  PUBLIC
  PRIVATE
  DEPRECATED
}

input PopFromRunQueueInput {
  entityName: String!
  projectName: String!
  queueName: String!
  launchAgentId: ID
  clientMutationId: String
}

type PopFromRunQueuePayload {
  runQueueItemId: ID
  runSpec: JSON
  clientMutationId: String
}

type Project implements Node {
  createdAt: DateTime!
  public: Boolean
  updatedAt: DateTime
  id: ID!
  ndbId: ID

  """deprecated"""
  entityId: Int
  userId: Int
  name: String!
  access: String
  repo: String
  dockerImage: String
  media: String
  groupPath: String
  subGroupPath: String
  views: JSONString
  description: String
  featured: Int
  storageBytes: Int64!
  computeHours: Duration!
  runs(jobKey: String, fields: [String], names: [String], filters: JSONString, order: String, groupKeys: [String], groupAggregation: GroupAggregation, groupLevel: Int, historyFields: [String], before: String, after: String, first: Int, last: Int): RunConnection
  buckets(jobKey: String, order: String, names: [String], before: String, after: String, first: Int, last: Int): RunConnection
  entity: Entity!

  """
  groups(fields: [String], level: String, filters: JSONString, order: String,
  historyFields: [String], before: String, after: String, first: Int, last:
  Int): GroupConnection
  """
  user: User
  allViews(userId: Int, viewType: String, userName: String, viewName: String, before: String, after: String, first: Int, last: Int, offset: Int): ViewConnection
  run(desc: String, name: String!): Run
  runGroup(name: String!): RunGroup
  bucket(desc: String, name: String!, missingOk: Boolean): Run
  runCount(filters: JSONString): Int!
  runActiveCount(filters: JSONString): Int!
  runOutputArtifactsCount(filters: JSONString): Int!
  pathCounts(filters: JSONString): JSONString
  valueCounts(keyPath: String, filters: JSONString): JSONString

  """deprecated"""
  runKeySuggestions(keyPath: String!, filters: JSONString): [RunKeySuggestion!]!
  summaryMetrics: JSONString
  entityName: String!
  requestSubscribe: Boolean
  sweeps(before: String, after: String, first: Int, last: Int, order: String): SweepConnection
  sweep(sweepName: String!): Sweep
  bucketCount: Int
  readOnly: Boolean
  totalSweeps: Int!
  totalRuns: Int
  totalUsers: Int
  lastActive: DateTime
  totalRunTime: Float
  totalRunsWithGroup: Int!
  totalRunsWithJobType: Int!
  tags: [Tag!]!
  tagCounts(filters: JSONString): [TagCount!]!
  isBenchmark: Boolean!
  gitHubSubmissionRepo: String
  linkedBenchmark: Project
  benchmarkRuns(
    """state is an enum of ACCEPTED/REJECTED/SUBMITTED"""
    state: String!
    before: String
    after: String
    first: Int
    last: Int
  ): BenchmarkRunConnection
  benchmarkSubmissions(before: String, after: String, first: Int, last: Int): BenchmarkRunConnection
  benchmarkDiscussionThreads(before: String, after: String, first: Int, last: Int): DiscussionThreadConnection!
  isPublished: Boolean!
  fields(types: [String!], columns: [String!], pattern: String, before: String, after: String, first: Int, last: Int): ProjectFieldConnection!
  artifactType(name: String!): ArtifactType
  artifactTypes(before: String, after: String, first: Int, last: Int): ArtifactTypeConnection!
  artifact(name: String!): Artifact
  artifactCollection(name: String!): ArtifactCollection
  artifactCollections(before: String, after: String, first: Int, last: Int, order: String, collectionTypes: [ArtifactCollectionType!]): ArtifactCollectionConnection
  parameterImportance(filters: JSONString, limit: Int, target: String!, parameters: [String!], runParameters: [String!]): JSON!
  runQueue(name: String!): RunQueue
  runQueues: [RunQueue!]!
  launchAgents: [LaunchAgent!]!
  defaultResourceConfigs(before: String, after: String, first: Int, last: Int): DefaultResourceConfigConnection
  triggers: [Trigger!]!
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge!]!
}

type ProjectEdge {
  node: Project
  cursor: String!
}

type ProjectField {
  path: String!
  type: String!
}

type ProjectFieldConnection {
  pageInfo: PageInfo!
  edges: [ProjectFieldEdge!]!
}

type ProjectFieldEdge {
  node: ProjectField!
  cursor: String!
}

input ProjectIdentifierInput {
  Name: String
  EntityName: String
}

input ProjectSpecifier {
  entityName: String!
  projectName: String!
}

type ProjectStorageNode implements StorageTreeNode {
  id: ID!
  name: String!
  size: Int64!
  project: Project!
  projectID: ID!
  runs(before: String, after: String, first: Int, last: Int): RunStorageNodeConnection!
  artifactSequences(before: String, after: String, first: Int, last: Int): ArtifactSequenceStorageNodeConnection!
}

type ProjectStorageNodeConnection {
  totalSize: Int64!
  pageInfo: PageInfo!
  edges: [ProjectStorageNodeEdge!]!
}

type ProjectStorageNodeEdge {
  node: ProjectStorageNode!
  cursor: String!
}

type PublicImageUploadInfo {
  uploadUrl: String!
  imageUrl: String!
  uploadHeaders: [String!]!
}

input PublishBenchmarkRunInput {
  id: ID!
  isCodeHidden: Boolean
  clientMutationId: String
  benchmarkName: String
  benchmarkEntityName: String
}

type PublishBenchmarkRunPayload {
  benchmarkRun: BenchmarkRun!
  clientMutationId: String
}

input PurgeUserInput {
  username: String!
  email: String!
  clientMutationId: String
}

type PurgeUserPayload {
  user: User
  clientMutationId: String
}

input PushToRunQueueByNameInput {
  entityName: String!
  projectName: String!
  queueName: String!
  runSpec: JSONString!
  clientMutationId: String
}

type PushToRunQueueByNamePayload {
  runQueueItemId: ID!
  clientMutationId: String
}

input PushToRunQueueInput {
  queueID: ID!
  runSpec: JSONString!
  clientMutationId: String
}

type PushToRunQueuePayload {
  runQueueItemId: ID!
  clientMutationId: String
}

type Query {
  models(entityName: String, keysOnly: Boolean, batchSize: Int, pageSize: Int, before: String, after: String, first: Int, last: Int): ProjectConnection
  model(name: String, entityName: String): Project
  viewer(entityName: String): User
  user(id: ID, userName: String): User
  entity(name: String, login: Boolean): Entity
  users(query: String, before: String, after: String, first: Int, last: Int, usernames: [String!], ids: [ID!]): UserConnection
  events(entityName: String, admin: Boolean, before: String, after: String, first: Int, last: Int): EventConnection
  project(name: String, entityName: String): Project
  projects(entityName: String, order: String, anonymous: Boolean, before: String, after: String, first: Int, last: Int): ProjectConnection
  benchmarks(entityName: String!, order: String, before: String, after: String, first: Int, last: Int): ProjectConnection
  publishedProjects(entityName: String!, order: String, before: String, after: String, first: Int, last: Int): ProjectConnection
  entities(order: String, before: String, after: String, first: Int, last: Int): EntityConnection
  trendingRepos(from: DateTime, before: String, after: String, first: Int, last: Int): RowConnection
  dataFrame(entityName: String!, projectName: String!, filters: JSONString, order: String, groupKeys: [String!], dataFrameKeys: [String!]!, columns: [String!], before: String, after: String, first: Int, last: Int): RowConnection
  dataFrameSchema(entityName: String!, projectName: String!, dataFrameKeys: [String!]!): [JSON!]!
  task(id: ID!): Task
  discussionThread(id: ID!): DiscussionThread
  discussionComment(id: ID!): DiscussionComment
  view(id: ID!, type: String): View
  views(ids: [ID!]!): ViewConnection
  publicViews(type: String, order: String, before: String, after: String, first: Int, last: Int): ViewConnection
  singletonView(type: String!): View
  featuredReports: View
  galleryTagSections: JSONString!
  highQualityUserProfiles: View
  serverInfo: ServerInfo
  plans: [Plan]!
  reportSearch(query: String!): ViewConnection
  organizations(ids: [ID!], emailDomain: String, query: String, before: String, after: String, first: Int, last: Int): OrganizationConnection!
  organization(id: ID, name: String): Organization
  customChart(id: ID!): CustomChart
  customCharts(type: String!, entity: String, userName: String, before: String, after: String, first: Int, last: Int): CustomChartConnection
  artifact(id: ID!): Artifact
  localLicenses(expired: Boolean = false): [LocalLicense]!
  publicImageUploadUrl: PublicImageUploadInfo
  invite(key: String!): Invite
  newsletterSubscriptions(order: String, before: String, after: String, first: Int, last: Int): NewsletterSubscriptionConnection
  clientIDMapping(clientID: ID!): ClientIDMapping
  artifactCollection(id: ID!): ArtifactCollection
  artifactSequence(id: ID!): ArtifactSequence
  instance: WBInstance
  rampManager: RampManager
  launchAgent(id: ID!): LaunchAgent
  repoInsightsPlotData(plotName: String!, repoName: String!, filters: JSONString, order: String, groupKeys: [String!], columns: [String!], before: String, after: String, first: Int, last: Int): RepoInsightsRowConnection
  repo(id: ID!): Repo
  activeExperiments: [ActiveExperiment!]!
  experiments: [Experiment!]!
}

input QueueJobActionInput {
  queueID: ID!
  template: JSONString!
}

"""| WebhookTriggeredAction"""
type QueueJobTriggeredAction {
  queue: RunQueue!
  template: JSONString!
}

type RampManager {
  settings: RampSettingConnection!
}

type RampSettingConnection {
  edges: [RampSettingEdge!]!
}

type RampSettingEdge {
  name: String!
  description: String!
  group: String!
  stores: [RampThresholdStore!]!
}

type RampSettingThreshold {
  checkId: String!
  threshold: Float!
}

type RampThresholdStore {
  name: String!
  thresholds: [RampSettingThreshold!]!
}

type RateLimits {
  filestream: Int!
  graphql: Int!
}

input RateLimitsInput {
  filestream: Int
  graphql: Int
}

input RemoveUserFromOrganizationInput {
  userName: String!
  organizationId: ID!
  clientMutationId: String
}

type RemoveUserFromOrganizationPayload {
  success: Boolean!
  clientMutationId: String
}

input RenameProjectInput {
  entityName: String!
  oldProjectName: String!
  newProjectName: String!
  clientMutationId: String
}

type Repo implements Node {
  id: ID!
  entity: Entity!
  displayName: String!
}

type RepoConnection {
  edges: [RepoEdge!]!
}

type RepoEdge {
  node: Repo
  cursor: String!
}

type RepoInsightsRowConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  schema: JSON!
  edges: [RowEdge!]!
  isNormalizedUserCount: Boolean!
}

input ResendEmailVerificationInput {
  email: String!
  clientMutationId: String
}

type ResendEmailVerificationPayload {
  success: Boolean!
  clientMutationId: String
}

input ResetPasswordInput {
  email: String!
  clientMutationId: String
}

type ResetPasswordPayload {
  success: Boolean!
}

input RevokeAccessTokenEmailInput {
  token: String!
  email: String!
  clientMutationId: String
}

type RevokeAccessTokenEmailPayload {
  accessToken: AccessToken!
  success: Boolean!
  clientMutationId: String
}

input RevokeAccessTokenInput {
  token: String!
  clientMutationId: String
}

type RevokeAccessTokenPayload {
  success: Boolean!
  clientMutationId: String
}

type RowConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  schema: JSON!
  edges: [RowEdge!]!
}

type RowEdge {
  node: RowType
}

type RowType {
  row: JSON!
}

type Run implements Node & BucketType {
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  projectId: ID!
  name: String!
  group: String
  jobType: String
  jobId: Int
  userId: Int
  sweepName: String
  config(keys: [String!], dotBehavior: DotBehavior = KEEP_ALL_DOT_VALUES): JSONString
  summaryMetrics(keys: [String!], packVersion: Int): JSONString
  wandbConfig(keys: [String!]): JSONString
  systemMetrics: JSONString
  state: String
  commit: String
  host: String
  exitcode: Float
  displayName: String
  notes: String
  description: String
  heartbeatAt: DateTime
  user: User
  tags: [String!]
  tagColors: [Tag!]!
  defaultColorIndex: Int
  project: Project
  model: Project
  id: ID!
  ndbId: ID
  sweep: Sweep
  agent: Agent
  fileCount: Int
  github: String
  storageBytes: Int64!
  files(pattern: String, names: [String], contentType: [String!], before: String, after: String, first: Int, last: Int): FileConnection
  runInfo: RunInfo
  logLines(before: String, after: String, first: Int, last: Int): LogLineConnection
  outputArtifacts(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): ArtifactConnection
  inputArtifacts(before: String, after: String, first: Int, last: Int, order: String, filters: JSONString): InputArtifactConnection
  history(samples: Int, minStep: Int64, maxStep: Int64): [String!]!
  sampledHistory(specs: [JSONString!]!, packVersion: Int): [JSON!]!
  historyKeys(format: HistoryKeysFormat = PLAINTEXT): JSON
  events(samples: Int): [String!]!
  logLineCount: Int
  historyLineCount: Int
  eventsLineCount: Int
  historyTail: JSONString
  eventsTail: JSONString
  patch: String
  requestSubscribe: Boolean
  shouldStop: Boolean
  framework: String
  groupCounts: [Int!]
  exampleTableColumns: JSONString
  exampleTableTypes: JSONString
  exampleTable: JSONString
  readOnly: Boolean
  debug: Boolean
  failed: Boolean
  stopped: Boolean
  running: Boolean
  servicesAvailable: RunServicesAvailable
  benchmarkRun: BenchmarkRun
  computeSeconds: Duration!
  pendingUpdates: Boolean!
}

type RunConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [RunEdge!]!
  paths: JSONString
  historyKeys(format: HistoryKeysFormat = PLAINTEXT): JSON
  delta(currentRuns: [String!]!, lastUpdated: DateTime!): [RunDiff!]!
}

type RunDiff {
  index: Int!
  op: DiffOperation!
  run: Run
}

type RunEdge {
  node: Run!
  cursor: String!
}

type RunGroup {
  id: ID!
  name: String!
  notes: String
  tags: [Tag!]!
  project: Project!
}

type RunInfo {
  program: String
  args: [String!]!
  os: String
  python: String
  colab: String
  executable: String
  codeSaved: Boolean
  cpuCount: Int
  gpuCount: Int
  gpu: String
  git: GitInfo
}

type RunKeySuggestion {
  value: JSONString
  displayValue: JSONString
  count: Int!
}

type RunQueue {
  createdAt: DateTime!
  updatedAt: DateTime
  id: ID!
  name: String!
  executorInfo: String! @deprecated(reason: "Executor state tracked in LaunchAgent.AgentStatus")
  createdBy: Int
  access: RunQueueAccessType!
  runQueueItem(id: ID!): RunQueueItem
  runQueueItems(before: String, after: String, first: Int, last: Int): RunQueueItemConnection!
  defaultResourceConfigID: ID
}

enum RunQueueAccessType {
  PROJECT
  USER
}

type RunQueueItem {
  createdAt: DateTime!
  updatedAt: DateTime
  id: ID!
  runSpec: JSON!
  state: RunQueueItemState!
  associatedRunId: String
  launchAgentId: ID
}

type RunQueueItemConnection {
  pageInfo: PageInfo!
  edges: [RunQueueItemEdge!]!
}

type RunQueueItemEdge {
  node: RunQueueItem!
  cursor: String!
}

enum RunQueueItemState {
  PENDING
  LEASED
  CLAIMED
}

type RunServicesAvailable {
  tensorboard: Boolean
}

type RunStorageNode implements StorageTreeNode {
  id: ID!
  name: String!
  size: Int64!
  run: Run!
  runID: ID!
  files(before: String, after: String, first: Int, last: Int): FileStorageNodeConnection!
}

type RunStorageNodeConnection {
  totalSize: Int64!
  pageInfo: PageInfo!
  edges: [RunStorageNodeEdge!]!
}

type RunStorageNodeEdge {
  node: RunStorageNode!
  cursor: String!
}

type ScriptableRunCondition {
  """GraphQL doesn't allow empty types, so this always returns true"""
  success: Boolean!
}

input SendRequestOrgEmailDomainVerificationInput {
  organizationID: ID!
  clientMutationId: String
}

type SendRequestOrgEmailDomainVerificationPayload {
  success: Boolean!
  clientMutationId: String
}

type ServerInfo {
  pollingOK: Boolean!
  availableCloudRegions: [CloudRegion!]!
  defaultCloudRegion: CloudRegion!
  slackClientID: String!
  cliVersionInfo: JSON!
  latestLocalVersionInfo: LocalVersionInfo
  messageOfTheDay: String
  isGoogleIap: Boolean!
  userLimitReached: Boolean!
  registeredModelLimitReached(entityName: String): Boolean!
  actionHistoryLimit(entityName: String, artifactCollectionID: ID): Int!
  frontendHost: String!
  hasLocalLicense: Boolean!
  licenseExpirationUI: LicenseExpirationUI
  exposesExplicitRunQueueAckPath: Boolean!
  availableBucketProviders: [CloudProvider!]!
}

input SetTagColorInput {
  entityName: String!
  projectName: String!
  tagName: String!
  colorIndex: Int
  clientMutationId: String
}

type SetTagColorPayload {
  tags: [Tag!]!
  clientMutationId: String
}

type SlackChannelSubscription implements AlertSubscription {
  id: ID!
  slackIntegration: SlackIntegration!
}

type SlackIntegration implements Integration {
  id: ID!
  teamName: String!
  channelName: String!
}

type StargazerConnection {
  pageInfo: PageInfo!
  edges: [StargazerEdge!]!
}

type StargazerEdge {
  node: User
  cursor: String!
}

input StartExperimentInput {
  id: ID!
  clientMutationId: String
}

input StarViewInput {
  id: ID!
  clientMutationId: String
}

type StarViewPayload {
  view: View
  clientMutationId: String
}

input StopExperimentInput {
  id: ID!
  clientMutationId: String
}

type StoppedRunCondition {
  minimumRunDuration: Duration!
}

input StopRunInput {
  id: ID!
  clientMutationId: String
}

type StopRunPayload {
  success: Boolean!
  clientMutationId: String
}

type StorageBucketInfo {
  ID: ID!
  provider: CloudProvider!
  name: String!
  kmsKeyID: String
  awsExternalID: String
}

input StorageBucketInfoInput {
  name: String!
  provider: CloudProvider!
  kmsKeyID: String
  awsExternalID: String
  organizationID: ID
}

interface StorageTreeNode {
  id: ID!
  name: String!
  size: Int64!
}

type StripeBillingInfo {
  stripeSubscriptionId: String!
  status: String!
  cancelAtPeriodEnd: Boolean!
  createdAt: DateTime!
  currentPeriodStart: DateTime!
  currentPeriodEnd: DateTime!
  invoiceLink: String
  paymentMethod: PaymentMethod
}

input SubmitBenchmarkRunInput {
  id: ID!
  isCodeHidden: Boolean
  clientMutationId: String
  benchmarkName: String
  benchmarkEntityName: String
}

type SubmitBenchmarkRunPayload {
  benchmarkRun: BenchmarkRun!
  clientMutationId: String
}

input SubmitFCProjectInput {
  spec: String!
  fcProjectID: String
  sendEmail: Boolean
  clientMutationId: String
}

type SubmitFCProjectPayload {
  success: Boolean!
  clientMutationId: String
}

type Sweep implements Node {
  id: ID!
  name: String!
  method: String!

  """TODO: enum?"""
  state: String!

  """TODO: enum?"""
  description: String
  user: User
  config: String!
  createdAt: DateTime!
  heartbeatAt: DateTime!
  updatedAt: DateTime
  earlyStopJobRunning: Boolean!
  project: Project
  controller: JSONString
  scheduler: JSONString
  displayName: String
  runCount: Int!

  """
  The number of runs that should be in the sweep when it completes. Grid search only.
  """
  runCountExpected: Int
  runTime: Int!
  bestLoss: Float

  """TODO: non-null?"""
  runs(order: String, before: String, after: String, first: Int, last: Int): RunConnection!
  priorRuns: RunConnection!
  agents: AgentConnection!
  agent(agentName: String!): Agent
  controllerRunName: String!
}

type SweepConnection {
  pageInfo: PageInfo!
  edges: [SweepEdge!]!
}

type SweepEdge {
  node: Sweep!
  cursor: String!
}

type Tag {
  name: String!
  colorIndex: Int!
}

type TagCount {
  name: String!
  count: Int!
}

type Task {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: String!
  state: TaskState!
  progress: Int!
  name: String!
}

enum TaskState {
  PENDING
  RUNNING
  FINISHED
  FAILED
}

type Trigger {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: User!
  name: String!
  description: String
  scope: TriggerScope!
  triggeringCondition: TriggeringCondition!
  triggeredAction: TriggeredAction!
  enabled: Boolean!
}

"""
type CronTriggeringCondition {
  schedule: CronSchedule!
  filter: String # when would this be used?
}
"""
union TriggeredAction = QueueJobTriggeredAction

input TriggeredActionConfig {
  queueJobActionInput: QueueJobActionInput
}

enum TriggeredActionType {
  QUEUE_JOB
}

union TriggeringCondition = FilterEventTriggeringCondition

union TriggerScope = Project | ArtifactSequence | ArtifactPortfolio

enum TriggerScopeType {
  PROJECT
  ARTIFACT_COLLECTION
}

input UndeleteRunsInput {
  entityName: String!
  projectName: String!
  filters: JSONString!
  clientMutationId: String
}

type UndeleteRunsPayload {
  clientMutationId: String
}

input UndeleteUserInput {
  id: ID!
  clientMutationId: String
}

type UndeleteUserPayload {
  user: User
  clientMutationId: String
}

input UnlinkArtifactInput {
  artifactID: ID!
  artifactPortfolioID: ID!
  clientMutationId: String
}

type UnlinkArtifactPayload {
  artifactID: ID!
  success: Boolean!
  clientMutationId: String
}

input UnstarViewInput {
  id: ID!
  clientMutationId: String
}

type UnstarViewPayload {
  view: View
  clientMutationId: String
}

input UpdateAccessTokenInput {
  token: String!
  email: String
  username: String
  clientMutationId: String
}

type UpdateAccessTokenPayload {
  accessToken: AccessToken!
  success: Boolean!
  toNewUser: Boolean
  recipientAlreadyOnTeam: Boolean
  clientMutationId: String
}

input UpdateAccessTokenProjectsInput {
  token: String!
  projects: [ProjectSpecifier!]!
  clientMutationId: String
}

type UpdateAccessTokenProjectsPayload {
  success: Boolean!
  clientMutationId: String
}

type UpdateAlertPayload {
  alert: Alert!
  clientMutationId: String
}

type UpdateArtifactAction implements ArtifactAction {
  id: ID!
  createdAt: DateTime!
  artifact: Artifact!
  initiator: Initiator!
  oldTags: JSONString
  newTags: JSONString
  oldAliases: [ArtifactAlias!]
  newAliases: [ArtifactAlias!]
  oldDescription: String
  newDescription: String
  oldMetadata: JSONString
  newMetadata: JSONString
}

type UpdateArtifactCollectionPayload {
  artifactCollection: ArtifactCollection!
  clientMutationId: String
}

input UpdateArtifactInput {
  artifactID: ID!
  description: String
  labels: JSONString
  aliases: [ArtifactAliasInput!]
  metadata: JSONString
  clientMutationId: String
}

input UpdateArtifactManifestInput {
  artifactManifestID: ID!
  baseArtifactID: ID
  digest: String
  clientMutationId: String
}

type UpdateArtifactManifestPayload {
  artifactManifest: ArtifactManifest!
  clientMutationId: String
}

type UpdateArtifactPayload {
  artifact: Artifact!
  artifactActions: [ArtifactAction!]!
  clientMutationId: String
}

input UpdateArtifactPortfolioInput {
  artifactPortfolioID: ID!
  name: String
  description: String
  clientMutationId: String
}

input UpdateArtifactSequenceInput {
  artifactSequenceID: ID!
  name: String
  description: String
  clientMutationId: String
}

input UpdateArtifactTypeInput {
  artifactTypeID: ID!
  description: String
  clientMutationId: String
}

type UpdateArtifactTypePayload {
  artifactType: ArtifactType!
  clientMutationId: String
}

input UpdateBenchmarkRunInput {
  id: ID!
  state: String
  details: JSONString
  clientMutationId: String
}

type UpdateBenchmarkRunPayload {
  benchmarkRun: BenchmarkRun!
  clientMutationId: String
}

input UpdateCustomChartInput {
  entity: String!
  name: String!
  displayName: String
  type: String
  access: String
  spec: JSONString
  clientMutationId: String
}

type UpdateCustomChartPayload {
  chart: CustomChart!
  clientMutationId: String
}

input UpdateCustomerPaymentMethodInput {
  organizationId: ID!
  paymentMethod: String!
  clientMutationId: String
}

type UpdateCustomerPaymentMethodPayload {
  success: Boolean
  clientMutationId: String
}

input UpdateDefaultResourceConfigInput {
  defaultResourceConfigID: ID!
  entityName: String
  projectName: String
  resource: String
  config: JSONString!
  clientMutationId: String
}

type UpdateDefaultResourceConfigPayload {
  success: Boolean!
  defaultResourceConfigID: ID!
}

input UpdateDiscussionCommentInput {
  viewID: ID
  discussionCommentID: ID!
  body: String!
  inlineCommentDetails: JSONString
  clientMutationId: String
}

type UpdateDiscussionCommentPayload {
  discussionComment: DiscussionComment!
  clientMutationId: String
}

input UpdateDiscussionThreadInput {
  discussionThreadID: ID!
  body: String!
  clientMutationId: String
}

type UpdateDiscussionThreadPayload {
  discussionThread: DiscussionThread!
  clientMutationId: String
}

input UpdateEntityInput {
  entity: String!
  photoUrl: String
  defaultAccess: String
  privateOnly: Boolean
  codeSavingEnabled: Boolean
  clientMutationId: String
  isPaid: Boolean
  rateLimits: RateLimitsInput
  settings: EntitySettingsInput
}

type UpdateEntityPayload {
  entity: Entity
  clientMutationId: String
}

input UpdateExperimentInput {
  id: ID!
  name: String!
  variants: [VariantInput!]!
  experimentType: ExperimentType!
  metadata: JSONString
  sampleSize: Int!
  enrollmentPeriod: Int!
  observationalUnit: ObservationalUnit!
  clientMutationId: String
}

type UpdateExperimentPayload {
  id: ID!
  success: Boolean!
  clientMutationId: String
}

input UpdateLaunchAgentInput {
  launchAgentId: ID!
  name: String
  runQueues: [ID!]
  agentStatus: String
  stopPolling: Boolean
  heartbeatAt: DateTime
  clientMutationId: String
}

type UpdateLaunchAgentPayload {
  success: Boolean
  clientMutationId: String
}

input UpdateLocalLicenseInput {
  id: ID!
  notes: String
  clientMutationId: String
}

type UpdateLocalLicensePayload {
  localLicense: LocalLicense!
  clientMutationId: String
}

input UpdateMemberInput {
  entityName: String!
  user: ID!
  admin: Boolean
  role: String
  clientMutationId: String
}

type UpdateMemberPayload {
  member: Member!
  clientMutationId: String
}

input UpdateOrganizationBillingUserInput {
  organizationId: ID!
  newBillingUser: ID!
  clientMutationId: String
}

type UpdateOrganizationBillingUserPayload {
  success: Boolean!
  clientMutationId: String
}

input UpdateOrganizationInput {
  organizationID: ID!
  flags: JSONString
  clientMutationId: String
}

type UpdateOrganizationPayload {
  success: Boolean!
  clientMutationId: String
}

input UpdateOrganizationSubscriptionInput {
  organizationSubscriptionID: ID!
  createStripeSubscription: Boolean = false
  planID: ID
  seats: Int
  privileges: JSONString
  type: OrganizationSubscriptionType
  status: OrganizationSubscriptionStatus
  stripeSubscriptionId: String
  expiresAt: DateTime
  clientMutationId: String
}

type UpdateOrganizationSubscriptionPayload {
  success: Boolean!
  clientMutationId: String
}

input UpdateOrganizationUserInput {
  userName: String!
  organizationId: ID!
  userOrgRole: String!
  clientMutationId: String
}

type UpdateOrganizationUserPayload {
  success: Boolean!
  clientMutationId: String
}

input UpdateRampThresholdInput {
  store: String!
  setting: String!
  checkId: String!
  threshold: Float!
  clientMutationId: String
}

type UpdateRampThresholdPayload {
  success: Boolean!
  clientMutationId: String
}

input UpdateStoppedRunAlertInput {
  id: ID!
  minimumRunDuration: Duration
  clientMutationId: String
}

input UpdateSubscriptionInput {
  entityName: String!
  teamsEnabled: Boolean
  privateProjects: Boolean
  gpuEnabled: DateTime
  hubPreset: String
  hubSettings: HubSettingsInput
  clientMutationId: String
}

type UpdateSubscriptionPayload {
  entity: Entity
  clientMutationId: String
}

input UpdateUserEmailInput {
  id: ID!
  type: EmailType
}

type UpdateUserEmailPayload {
  success: Boolean!
  email: Email
}

input UpdateUserInput {
  id: ID

  """null implies "self" -- only admins can edit others"""
  primaryEmail: String
  defaultEntity: String
  defaultFramework: String

  """deprecated"""
  photoUrl: String
  code: String
  name: String
  userInfo: JSONString
  hideTeamsFromPublic: Boolean
  settingsVisited: Boolean
  galleryVisited: Boolean
  onboardingHidden: Boolean
  private: Boolean
  admin: Boolean
  password: String
  clientMutationId: String
}

type UpdateUserPayload {
  user: User
  clientMutationId: String
}

input UpgradeCustomerSubscriptionInput {
  planID: ID!
  organizationID: ID!
  paymentMethod: String!
  quantity: Int!
  clientMutationId: String
}

type UpgradeCustomerSubscriptionPayload {
  subscription: JSON
  clientMutationId: String
  organizationID: ID!
}

input UpsertBucketInput {
  name: String
  groupName: String
  displayName: String
  notes: String
  description: String
  sweep: String
  id: String
  framework: String

  """deprecated"""
  config: JSONString
  summaryMetrics: JSONString
  commit: String
  state: String
  host: String
  debug: Boolean
  entityName: String
  modelName: String
  jobProgram: String
  jobRepo: String
  jobType: String
  tags: [String]
  runQueueItemId: ID
  clientMutationId: String
}

type UpsertBucketPayload {
  bucket: Run
  inserted: Boolean
  updateAvailable: Boolean
  clientMutationId: String
}

input UpsertModelInput {
  name: String
  description: String
  id: String
  framework: String

  """deprecated"""
  entityName: String
  dockerImage: String
  repo: String
  access: String
  views: JSONString
  isBenchmark: Boolean
  linkedBenchmark: ID
  isPublished: Boolean
  clientMutationId: String
}

type UpsertModelPayload {
  model: Project
  project: Project
  entityName: String
  inserted: Boolean
  clientMutationId: String
}

input UpsertRunGroupInput {
  entityName: String!
  projectName: String!
  name: String!
  newName: String
  tags: [String!]
  notes: String
  clientMutationId: String
}

type UpsertRunGroupPayload {
  group: RunGroup
  inserted: Boolean
  clientMutationId: String
}

input UpsertSharedViewInput {
  entityName: String!
  name: String!
  type: String!
  description: String
  spec: String!
  clientMutationId: String
}

type UpsertSharedViewPayload {
  view: View
  clientMutationId: String
}

input UpsertSweepInput {
  entityName: String
  projectName: String
  id: ID
  config: String
  description: String
  state: String
  controller: JSONString
  launchScheduler: JSONString
  scheduler: JSONString
  priorRunsFilters: JSONString
  displayName: String
  clientMutationId: String
}

type UpsertSweepPayload {
  sweep: Sweep
  inserted: Boolean
  insertedPriorRuns: Int
  clientMutationId: String
  configValidationWarnings: [String!]!
}

input UpsertViewInput {
  id: ID
  entityName: String
  projectName: String
  name: String
  displayName: String
  description: String
  type: String
  spec: String
  parentId: ID
  locked: Boolean
  previewUrl: String
  coverUrl: String
  clientMutationId: String
  showcasedAt: DateTime
  createdUsing: ViewSource
}

type UpsertViewPayload {
  view: View
  inserted: Boolean
  clientMutationId: String
}

type UsageStat {
  date: DateTime
  stat: Float
}

type UsageStatConnection {
  pageInfo: PageInfo!
  edges: [UsageStatEdge!]!
}

type UsageStatEdge {
  node: UsageStat!
  cursor: String!
}

type UseArtifactAction implements ArtifactAction {
  id: ID!
  createdAt: DateTime!
  artifact: Artifact!
  initiator: Initiator!
}

input UseArtifactInput {
  entityName: String!
  projectName: String!
  runName: String!
  artifactID: ID!
  usedAs: String
  clientMutationId: String
}

type UseArtifactPayload {
  run: Run!
  artifact: Artifact!
  clientMutationId: String
}

type User implements Node {
  createdAt: DateTime!
  updatedAt: DateTime
  id: ID!
  ndbId: ID @deprecated
  email: String
  emails: [Email!]!
  authId: String @deprecated
  name: String!
  username: String
  photoUrl: String
  photoUploadUrl: String!
  uploadHeaders: [String!]!
  admin: Boolean
  defaultEntityId: Int
  accountType: UserAccountType
  loggedInAt: DateTime
  defaultEntity: Entity
  userEntity: Entity
  userInfo: JSON
  hideTeamsFromPublic: Boolean!
  limits: JSON
  onboardingSteps: JSON
  private: Boolean!
  signupRequired: Boolean!
  stripeCustomerId: String
  newsletterSubscription: NewsletterSubscription
  deletedAt: DateTime
  projects(
    before: String
    after: String
    first: Int
    last: Int
    order: String
    restrictTo: UserProjectRestriction = OWNED

    """deprecated"""
    linkedBenchmark: ProjectIdentifierInput
  ): ProjectConnection
  views(viewType: String, before: String, after: String, first: Int, last: Int): ViewConnection
  starredViews(before: String, after: String, first: Int, last: Int): ViewConnection
  apiKeys(keysOnly: Boolean, batchSize: Int, pageSize: Int, before: String, after: String, first: Int, last: Int): ApiKeyConnection
  apiKey: String
  entity: String
  defaultFramework: String
  flags: JSONString
  code: String
  teams(before: String, after: String, first: Int, last: Int): EntityConnection
  organizations(emailDomain: String): [Organization!]!
  dailyRunCount(limit: Int!): [Int!]!
  totalRuns: Int!
  runs(order: String, before: String, after: String, first: Int, last: Int): RunConnection
}

enum UserAccountType {
  USER
  SERVICE
  ANONYMOUS
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge!]!
}

type UserEdge {
  node: User
  cursor: String!
}

"""deprecated"""
enum UserProjectRestriction {
  OWNED
  CONTRIBUTED
}

type Variant {
  bucket: Int!
  allocation: Int!
  description: String!
}

input VariantInput {
  bucket: Int!
  allocation: Int!
  description: String!
}

type VersionedArtifactConnection implements ArtifactConnectionType {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [VersionedArtifactEdge!]!
}

type VersionedArtifactEdge implements ArtifactEdgeType {
  node: Artifact!
  version: String!
  cursor: String!
}

type View implements Node {
  createdAt: DateTime!
  updatedAt: DateTime
  updatedBy: User
  id: ID!
  name: String
  displayName: String
  type: String
  userId: Int
  projectId: Int
  description: String
  imageUploadUrl(name: String!): ImageUrl!
  uploadHeaders: [String!]!
  previewUrl: String
  coverUrl: String
  spec: JSONString
  user: User
  project: Project
  entity: Entity
  entityName: String!
  projectName: String!
  starCount(from: DateTime, to: DateTime): Int!
  starred: Boolean
  stargazers(before: String, after: String, first: Int, last: Int): StargazerConnection!
  children: ViewConnection
  parentId: ID
  locked: Boolean!
  viewCount: Int!
  showcasedAt: DateTime
  createdUsing: ViewSource!
  discussionThreads(before: String, after: String, first: Int, last: Int): DiscussionThreadConnection!
  alertSubscription: AlertSubscription
  accessTokens: [AccessToken!]!
}

type ViewConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ViewEdge!]!
}

type ViewEdge {
  node: View
  cursor: String!
}

enum ViewSource {
  WANDB_UI
  WANDB_UI_SHARE_PANEL
  WANDB_SDK
}

input ViewViewInput {
  id: ID!
  clientMutationId: String
}

type ViewViewPayload {
  success: Boolean
  clientMutationId: String
}

type WBInstance {
  entities: [Entity!]!
  views(before: String, after: String, first: Int, last: Int, limit: Int, offset: Int): ViewConnection!
  artifactSequences(before: String, after: String, first: Int, last: Int, limit: Int, offset: Int, filters: JSONString): ArtifactSequenceConnection
  projects(before: String, after: String, first: Int, last: Int): ProjectConnection
}

